### æ–¹æ³•ä¸€ï¼šæ•°ä½ DP

è¿™é“é¢˜å®žé™…ä¸Šæ˜¯æ±‚åœ¨ç»™å®šåŒºé—´ $[l,..r]$ ä¸­ï¼Œæ•°å­—çš„äºŒè¿›åˆ¶è¡¨ç¤ºä¸åŒ…å«è¿žç»­çš„ $1$ çš„ä¸ªæ•°ã€‚ä¸ªæ•°ä¸Žæ•°çš„ä½æ•°ä»¥åŠæ¯ä¸ªäºŒè¿›åˆ¶ä½ä¸Šçš„æ•°å­—æœ‰å…³ã€‚æˆ‘ä»¬å¯ä»¥ç”¨æ•°ä½ DP çš„æ€è·¯æ¥è§£å†³è¿™é“é¢˜ã€‚æ•°ä½ DP ä¸­ï¼Œæ•°çš„å¤§å°å¯¹å¤æ‚åº¦çš„å½±å“å¾ˆå°ã€‚

å¯¹äºŽåŒºé—´ $[l,..r]$ é—®é¢˜ï¼Œæˆ‘ä»¬ä¸€èˆ¬ä¼šå°†å…¶è½¬åŒ–ä¸º $[0,..r]$ ç„¶åŽå†å‡åŽ» $[0,..l - 1]$ çš„é—®é¢˜ï¼Œå³ï¼š

$$
ans = \sum_{i=0}^{r} ans_i -  \sum_{i=0}^{l-1} ans_i
$$

ä¸è¿‡å¯¹äºŽæœ¬é¢˜è€Œè¨€ï¼Œæˆ‘ä»¬åªéœ€è¦æ±‚å‡ºåŒºé—´ $[0,..r]$ çš„å€¼å³å¯ã€‚

è¿™é‡Œæˆ‘ä»¬ç”¨è®°å¿†åŒ–æœç´¢æ¥å®žçŽ°æ•°ä½ DPã€‚åŸºæœ¬æ­¥éª¤å¦‚ä¸‹ï¼š

1. å°†æ•°å­— $n$ è½¬ä¸ºäºŒè¿›åˆ¶å­—ç¬¦ä¸² $s$ï¼›
2. æ ¹æ®é¢˜ç›®ä¿¡æ¯ï¼Œè®¾è®¡å‡½æ•° $\textit{dfs}()$ï¼Œå¯¹äºŽæœ¬é¢˜ï¼Œæˆ‘ä»¬å®šä¹‰ $\textit{dfs}(\textit{pos}, \textit{pre}, \textit{limit})$ï¼Œç­”æ¡ˆä¸º $\textit{dfs}(\textit{0}, 0, \textit{true})$ã€‚

å…¶ä¸­ï¼š

- `pos` è¡¨ç¤ºæ•°å­—çš„ä½æ•°ï¼Œæˆ‘ä»¬ä»Žæ•°å­—çš„æœ€é«˜ä½å¼€å§‹ï¼Œå³äºŒè¿›åˆ¶å­—ç¬¦ä¸²çš„é¦–å­—ç¬¦ï¼›
- `pre` è¡¨ç¤ºå½“å‰æ•°å­—äºŒè¿›åˆ¶ä½ä¸Šçš„æ•°å­—ï¼Œå¯¹äºŽæœ¬é¢˜ï¼Œ`pre` çš„åˆå§‹å€¼ä¸º `0`ï¼›
- `limit` è¡¨ç¤ºå¯å¡«çš„æ•°å­—çš„é™åˆ¶ï¼Œå¦‚æžœæ— é™åˆ¶ï¼Œé‚£ä¹ˆå¯ä»¥é€‰æ‹© $[0,1]$ï¼Œå¦åˆ™ï¼Œåªèƒ½é€‰æ‹© $[0,..s[\textit{pos}]]$ã€‚

å…³äºŽå‡½æ•°çš„å®žçŽ°ç»†èŠ‚ï¼Œå¯ä»¥å‚è€ƒä¸‹é¢çš„ä»£ç ã€‚

* [sol1-Python3]

```python
class Solution:
    def findIntegers(self, n: int) -> int:
        @cache
        def dfs(pos: int, pre: int, limit: bool) -> int:
            if pos == len(s):
                return 1
            up = int(s[pos]) if limit else 1
            ans = 0
            for i in range(up + 1):
                if pre == 1 and i == 1:
                    continue
                ans += dfs(pos + 1, i, limit and i == up)
            return ans

        s = bin(n)[2:]
        return dfs(0, 0, True)
```

* [sol1-Java]

```java
class Solution {
    private char[] s;
    private Integer[][] f;

    public int findIntegers(int n) {
        s = Integer.toBinaryString(n).toCharArray();
        f = new Integer[s.length][2];
        return dfs(0, 0, true);
    }

    private int dfs(int pos, int pre, boolean limit) {
        if (pos >= s.length) {
            return 1;
        }
        if (!limit && f[pos][pre] != null) {
            return f[pos][pre];
        }
        int up = limit ? s[pos] - '0' : 1;
        int ans = 0;
        for (int i = 0; i <= up; ++i) {
            if (!(pre == 1 && i == 1)) {
                ans += dfs(pos + 1, i, limit && i == up);
            }
        }
        if (!limit) {
            f[pos][pre] = ans;
        }
        return ans;
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int findIntegers(int n) {
        string s = bitset<32>(n).to_string();
        s = s.substr(s.find('1'));
        int m = s.size();
        int f[m][2];
        memset(f, -1, sizeof(f));
        auto dfs = [&](auto&& dfs, int pos, int pre, bool limit) -> int {
            if (pos >= m) {
                return 1;
            }
            if (!limit && f[pos][pre] != -1) {
                return f[pos][pre];
            }
            int up = limit ? s[pos] - '0' : 1;
            int ans = 0;
            for (int i = 0; i <= up; ++i) {
                if (!(pre == 1 && i == 1)) {
                    ans += dfs(dfs, pos + 1, i, limit && i == up);
                }
            }
            if (!limit) {
                f[pos][pre] = ans;
            }
            return ans;
        };
        return dfs(dfs, 0, 0, true);
    }
};
```

* [sol1-Go]

```go
func findIntegers(n int) int {
	s := strconv.FormatInt(int64(n), 2)
	m := len(s)
	f := make([][]int, m)
	for i := range f {
		f[i] = []int{-1, -1}
	}
	var dfs func(int, int, bool) int
	dfs = func(pos int, pre int, limit bool) int {
		if pos >= m {
			return 1
		}
		if !limit && f[pos][pre] != -1 {
			return f[pos][pre]
		}
		up := 1
		if limit {
			up = int(s[pos] - '0')
		}
		ans := 0
		for i := 0; i <= up; i++ {
			if !(pre == 1 && i == 1) {
				ans += dfs(pos+1, i, limit && i == up)
			}
		}
		if !limit {
			f[pos][pre] = ans
		}
		return ans
	}
	return dfs(0, 0, true)
}
```

* [sol1-TypeScript]

```ts
function findIntegers(n: number): number {
    const s = n.toString(2);
    const m = s.length;
    const f: number[][] = Array.from({ length: m }, () => [-1, -1]);

    function dfs(pos: number, pre: number, limit: boolean): number {
        if (pos >= m) {
            return 1;
        }
        if (!limit && f[pos][pre] !== -1) {
            return f[pos][pre];
        }
        const up = limit ? parseInt(s[pos]) : 1;
        let ans = 0;
        for (let i = 0; i <= up; ++i) {
            if (!(pre === 1 && i === 1)) {
                ans += dfs(pos + 1, i, limit && i === up);
            }
        }
        if (!limit) {
            f[pos][pre] = ans;
        }
        return ans;
    }

    return dfs(0, 0, true);
}
```

æ—¶é—´å¤æ‚åº¦ $O(\log n)$ï¼Œç©ºé—´å¤æ‚åº¦ $O(\log n)$ã€‚å…¶ä¸­ $n$ ä¸ºé¢˜ç›®ç»™å®šçš„æ•°å­—ã€‚

----

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~

